/*
 * govm p2p api
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	"github.com/govm-net/govm/conf"
	core "github.com/govm-net/govm/core"
	"github.com/govm-net/govm/event"
	"github.com/govm-net/govm/handler"
	"github.com/govm-net/govm/messages"
	"github.com/govm-net/govm/runtime"
	"github.com/govm-net/govm/wallet"
)

// Account account
type Account struct {
	Chain   uint64 `json:"chain,omitempty"`
	Address string `json:"address,omitempty"`
	Cost    uint64 `json:"cost,omitempty"`
}

// AccountGet get account of the address on the chain
func AccountGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	r.ParseForm()
	chainStr := vars["chain"]
	addrStr := r.Form.Get("address")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var addr []byte
	// if addrStr == "" {
	// 	c := conf.GetConf()
	// 	addrStr = hex.EncodeToString(c.WalletAddr)
	// }
	addr, err = hex.DecodeString(addrStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error address,must hex string"))
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	out := Account{}
	out.Chain = chain
	out.Address = addrStr
	out.Cost = core.GetUserCoin(chain, addr)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// TransactionNew new transaction
func TransactionNew(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	key := runtime.GetHash(data)
	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = data
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}
	// w.WriteHeader(http.StatusOK)
	info := RespOfNewTrans{}
	info.TransKey = hex.EncodeToString(key)
	info.Chain = chain

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransMoveInfo move info
type TransMoveInfo struct {
	DstChain uint64 `json:"dst_chain,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionMovePost move cost to other chain
func TransactionMovePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := TransMoveInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateMove(info.DstChain, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransferInfo transfer info
type TransferInfo struct {
	Peer     string `json:"peer,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionTransferPost transfer
func TransactionTransferPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := TransferInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Cost == 0 {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error cost value,", info.Cost)
		return
	}
	dst, err := hex.DecodeString(info.Peer)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error address of peer,", info.Peer, err)
		return
	}
	if len(dst) != wallet.AddressLength {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error length of peer address,", info.Peer)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	dstAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	runtime.Decode(dst, &dstAddr)
	log.Printf("transfer,from:%x,to:%x,cost:%d\n", cAddr, dstAddr, info.Cost)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateTransfer(dstAddr, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// Miner miner info
type Miner struct {
	TargetChain uint64 `json:"target_chain,omitempty"`
	Cost        uint64 `json:"cost,omitempty"`
	Energy      uint64 `json:"energy,omitempty"`
	Miner       string `json:"miner,omitempty"`
	TransKey    string `json:"trans_key,omitempty"`
}

// TransactionMinerPost register miner
func TransactionMinerPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := Miner{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	var peer []byte
	if info.Miner != "" {
		peer, err = hex.DecodeString(info.Miner)
	}
	trans.RegisterMiner(info.TargetChain, info.Cost, peer)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// NewApp new app
type NewApp struct {
	Cost         uint64 `json:"cost,omitempty"`
	Energy       uint64 `json:"energy,omitempty"`
	CodePath     string `json:"code_path,omitempty"`
	IsPrivate    bool   `json:"is_private,omitempty"`
	EnableRun    bool   `json:"enable_run,omitempty"`
	EnableImport bool   `json:"enable_import,omitempty"`
	AppName      string `json:"app_name,omitempty"`
	TransKey     string `json:"trans_key,omitempty"`
}

// TransactionNewAppPost new app
func TransactionNewAppPost(w http.ResponseWriter, r *http.Request) {
	defer func() {
		err := recover()
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "error code:", err)
		}
	}()
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := NewApp{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	var flag uint8
	if !info.IsPrivate {
		flag |= core.AppFlagPlublc
		log.Println("1. flag:", flag)
	}
	if info.EnableRun {
		flag |= core.AppFlagRun
		log.Println("2. flag:", flag)
	}
	if info.EnableImport {
		flag |= core.AppFlagImport
		log.Println("3. flag:", flag)
	}
	code, ln := core.CreateAppFromSourceCode(info.CodePath, flag)
	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateNewApp(code, ln)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	codeHS := runtime.GetHash(code)
	if info.IsPrivate {
		codeHS = runtime.GetHash(append(codeHS, trans.User[:]...))
	}
	info.AppName = hex.EncodeToString(codeHS)
	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// RunApp run app
type RunApp struct {
	Cost      uint64      `json:"cost,omitempty"`
	Energy    uint64      `json:"energy,omitempty"`
	AppName   string      `json:"app_name,omitempty"`
	Param     string      `json:"param,omitempty"`
	ParamType string      `json:"param_type,omitempty"`
	JSONParam interface{} `json:"json_param,omitempty"`
}

// RespOfNewTrans the response of New Transaction
type RespOfNewTrans struct {
	Chain    uint64 `json:"chain,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionRunAppPost run app
func TransactionRunAppPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := RunApp{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	log.Println("run app:", info)
	var param []byte
	switch info.ParamType {
	case "json":
		if len(info.Param) > 0 {
			prefix, err := hex.DecodeString(info.Param)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				fmt.Fprintln(w, "error param, hope hex string,", err)
				return
			}
			param = prefix
		}
		jData, _ := json.Marshal(info.JSONParam)
		param = append(param, jData...)
	case "string":
		param = []byte(info.Param)
	default:
		if len(info.Param) > 0 {
			param, err = hex.DecodeString(info.Param)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				fmt.Fprintln(w, "error param, hope hex string,", err)
				return
			}
		}
	}
	app := core.Hash{}
	{
		d, err := hex.DecodeString(info.AppName)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "error AppName, hope hex string,", err)
			return
		}
		runtime.Decode(d, &app)
	}
	if (app == core.Hash{}) {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error AppName, fail to decode,", info.AppName)
		return
	}

	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateRunApp(app, info.Cost, param)

	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = trans.Key[:]
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	resp := RespOfNewTrans{chain, hex.EncodeToString(trans.Key[:])}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(resp)
}

// AppLife app life
type AppLife struct {
	Energy   uint64 `json:"energy,omitempty"`
	AppName  string `json:"app_name,omitempty"`
	Life     uint64 `json:"life,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionAppLifePost update app life
func TransactionAppLifePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := AppLife{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	app := core.Hash{}
	d, err := hex.DecodeString(info.AppName)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error param, hope hex string,", err)
		return
	}
	runtime.Decode(d, &app)

	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Energy {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Energy)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateUpdateAppLife(app, info.Life)

	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = trans.Key[:]
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(trans.Key[:])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransactionAppInfoGet get app info
func TransactionAppInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	key, err = hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}
	info := core.GetAppInfoOfChain(chain, key)
	if info == nil {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("error key"))
		fmt.Fprintf(w, "chain:%d,key:%x", chain, key)
		return
	}
	log.Println("app info:", info)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransInfo transaction info
type TransInfo struct {
	core.TransactionHead
	Key    []byte
	Size   int
	Others interface{}
}

// TransactionInfoGet get transaction info
func TransactionInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	key, err = hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}

	data := core.ReadTransactionData(chain, key)
	if len(data) == 0 {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("error key"))
		fmt.Fprintf(w, "chain:%d,key:%x", chain, key)
		return
	}
	trans := core.DecodeTrans(data)
	if trans == nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}

	info := TransInfo{}
	info.TransactionHead = trans.TransactionHead
	info.Key = key
	si := core.DecodeOpsDataOfTrans(info.Ops, trans.Data)
	ti := core.GetTransInfo(chain, key)
	si["BlockID"] = ti.BlockID
	info.Others = si
	info.Size = len(data)

	d, _ := json.Marshal(info.Others)
	log.Println("trans info:", info.Others, string(d))

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// BlockMinePost mine
func BlockMinePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}

	msg := new(messages.Mine)
	msg.Chain = chain
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(msg)
}

type blockInfo struct {
	Time          uint64 `json:"time,omitempty"`
	Previous      string `json:"previous,omitempty"`
	Parent        string `json:"parent,omitempty"`
	LeftChild     string `json:"left_child,omitempty"`
	RightChild    string `json:"right_child,omitempty"`
	TransListHash string `json:"trans_list_hash,omitempty"`
	Producer      string `json:"producer,omitempty"`
	Chain         uint64 `json:"chain,omitempty"`
	Index         uint64 `json:"index,omitempty"`
	Nonce         uint64 `json:"nonce,omitempty"`
	Key           string `json:"key,omitempty"`
}

// BlockInfoGet get block info
func BlockInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	indexStr := r.Form.Get("index")
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var index uint64
	if indexStr != "" {
		index, err = strconv.ParseUint(indexStr, 10, 64)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error index"))
			return
		}
	}
	var key []byte
	if keyStr != "" {
		key, err = hex.DecodeString(keyStr)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error key"))
			return
		}
	} else {
		key = core.GetTheBlockKey(chain, index)
	}
	data := core.ReadBlockData(chain, key)
	if len(data) == 0 {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "error key.chain:%d,key:%x,index:%d\n", chain, key, index)
		return
	}
	block := core.DecodeBlock(data)
	info := blockInfo{}
	info.Time = block.Time
	info.Previous = hex.EncodeToString(block.Previous[:])
	if !block.Parent.Empty() {
		info.Parent = hex.EncodeToString(block.Parent[:])
	}
	if !block.LeftChild.Empty() {
		info.LeftChild = hex.EncodeToString(block.LeftChild[:])
	}
	if !block.RightChild.Empty() {
		info.RightChild = hex.EncodeToString(block.RightChild[:])
	}
	if !block.TransListHash.Empty() {
		info.TransListHash = hex.EncodeToString(block.TransListHash[:])
	}
	info.Producer = hex.EncodeToString(block.Producer[:])
	info.Chain = block.Chain
	info.Index = block.Index
	info.Nonce = block.Nonce
	info.Key = hex.EncodeToString(block.Key[:])

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// ChainNewInfo info of new chain
type ChainNewInfo struct {
	DstChain uint64 `json:"dst_chain,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// ChainNew new chain
func ChainNew(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := ChainNewInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.DstChain/2 != chain {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error dst chain,", info.DstChain)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateNewChain(info.DstChain, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// DataInfo data info
type DataInfo struct {
	AppName    string `json:"app_name,omitempty"`
	StructName string `json:"struct_name,omitempty"`
	IsDBData   bool   `json:"is_db_data,omitempty"`
	Key        string `json:"key,omitempty"`
	Value      string `json:"value,omitempty"`
	Life       uint64 `json:"life,omitempty"`
}

// DataGet read data
func DataGet(w http.ResponseWriter, r *http.Request) {
	info := DataInfo{}
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	info.AppName = r.Form.Get("app_name")
	info.StructName = r.Form.Get("struct_name")
	info.Key = r.Form.Get("key")
	raw := r.Form.Get("raw")
	if r.Form.Get("is_db_data") == "true" {
		info.IsDBData = true
	}
	if info.AppName == "" {
		info.AppName = "ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	}

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}

	key, err := hex.DecodeString(info.Key)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Decode preKey,", info.Key, err)
		return
	}
	val, life := runtime.GetValue(chain, info.IsDBData, info.AppName, info.StructName, key)
	if raw == "true" {
		w.WriteHeader(http.StatusOK)
		w.Write(val)
		return
	}
	info.Value = hex.EncodeToString(val)
	info.Life = life

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// DataPost post data
func DataPost(w http.ResponseWriter, r *http.Request) {
	info := new(messages.RawData)
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	isTrans := r.Form.Get("is_trans")
	broadcast := r.Form.Get("broadcast")

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	key, err := hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Decode preKey,", keyStr, err)
		return
	}

	info.Chain = chain
	info.Key = key
	info.Data = data
	if isTrans == "true" {
		info.IsTrans = true
	}
	if broadcast == "true" {
		info.Broadcast = true
	}
	// log.Printf("new data,type:%v,chain:%d,key:%x\n", info.IsTrans, chain, key)
	err = event.Send(info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "%s", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// DataExist return 200OK when exist the key
func DataExist(w http.ResponseWriter, r *http.Request) {
	info := DataInfo{}
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	info.AppName = r.Form.Get("app_name")
	info.StructName = r.Form.Get("struct_name")
	info.Key = r.Form.Get("key")
	if r.Form.Get("is_db_data") == "true" {
		info.IsDBData = true
	}
	if info.AppName == "" {
		info.AppName = "ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
	}

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}

	key, err := hex.DecodeString(info.Key)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Decode preKey,", info.Key, err)
		return
	}
	exist := runtime.KeyExist(chain, info.IsDBData, info.AppName, info.StructName, key)
	if exist {
		w.WriteHeader(http.StatusOK)
	} else {
		w.WriteHeader(http.StatusNotFound)
	}
}

// DataNextKey the next key of data
type DataNextKey struct {
	AppName    string `json:"app_name,omitempty"`
	StructName string `json:"struct_name,omitempty"`
	PreKey     string `json:"pre_key,omitempty"`
	IsDBData   bool   `json:"is_db_data,omitempty"`
	Key        string `json:"key,omitempty"`
}

// DataNextKeyGet get next key
func DataNextKeyGet(w http.ResponseWriter, r *http.Request) {
	info := DataNextKey{}
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	info.AppName = r.Form.Get("app_name")
	info.StructName = r.Form.Get("struct_name")
	info.PreKey = r.Form.Get("pre_key")
	if r.Form.Get("is_db_data") == "true" {
		info.IsDBData = true
	}

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var preKey []byte
	if info.PreKey != "" {
		preKey, err = hex.DecodeString(info.PreKey)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to Decode preKey,", info.PreKey, err)
			return
		}
	}
	key := runtime.GetNextKey(chain, info.IsDBData, info.AppName, info.StructName, preKey)
	info.Key = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// EventInfo event
type EventInfo struct {
	Who   string
	Event string
	Param string
}

// EventPost mine
func EventPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := EventInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}

	msg := new(messages.ChainEvent)
	msg.Chain = chain
	msg.Who = info.Who
	msg.Event = info.Event
	msg.Param = info.Param
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// NodePost add new node
func NodePost(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := messages.NewNode{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}

	err = event.Send(&info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

// NodesGet get nodes
func NodesGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(handler.GetNodes())
}

// NodeInfo node info
type NodeInfo struct {
	Address    string `json:"address,omitempty"`
	Miners     int    `json:"miners,omitempty"`
	NodeNumber int    `json:"node_number,omitempty"`
}

// NodeAddressGet get self node address
func NodeAddressGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	info := NodeInfo{handler.SelfAddress, 0, handler.NodesCount}
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// VersionInfo version info
type VersionInfo struct {
	Version   string
	BuildTime string
	GitHead   string
}

// VersionGet get software version
func VersionGet(w http.ResponseWriter, r *http.Request) {
	info := VersionInfo{conf.Version, conf.BuildTime, conf.GitHead}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// CryptoInfo crypto info
type CryptoInfo struct {
	Owner   string `json:"owner,omitempty"`
	Sign    string `json:"sign,omitempty"`
	Message string `json:"message,omitempty"`
	HexMsg  bool   `json:"hex_msg,omitempty"`
}

// CryptoSign crypto:sign message
func CryptoSign(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := CryptoInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Message == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not message")
		return
	}
	msg := []byte(info.Message)
	if info.HexMsg {
		msg, err = hex.DecodeString(info.Message)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to DecodeString message,", err)
			return
		}
	}

	c := conf.GetConf()
	sign := wallet.Sign(c.PrivateKey, msg)
	info.Owner = hex.EncodeToString(c.WalletAddr)
	info.Sign = hex.EncodeToString(sign)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// CryptoCheck Crypto:check the sign
func CryptoCheck(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := CryptoInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Owner == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not owner")
		return
	}
	if info.Message == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not message")
		return
	}
	if info.Sign == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not sign")
		return
	}
	msg := []byte(info.Message)
	if info.HexMsg {
		msg, err = hex.DecodeString(info.Message)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to DecodeString message,", err)
			return
		}
	}
	sign, err := hex.DecodeString(info.Sign)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to DecodeString sign,", err)
		return
	}

	addr, err := hex.DecodeString(info.Owner)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to DecodeString sign,", err)
		return
	}

	rst := wallet.Recover(addr, sign, msg)
	if !rst {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	w.WriteHeader(http.StatusOK)
}

// HashPowerGet get hashpower info
func HashPowerGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	mainnetHP := handler.GetHashPowerOfBlocks(chain)
	myHP := handler.GetMyHashPower(chain)
	type HP struct {
		NetHP  uint64 `json:"net_hp"`
		NodeHP uint64 `json:"node_hp"`
	}
	out := HP{mainnetHP, myHP}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// TimeGet get the node time(Unix)
func TimeGet(w http.ResponseWriter, r *http.Request) {
	t := time.Now().Unix()
	fmt.Fprintf(w, "%d", t)
}

// TrustedBlockGet get the trusted blocks
func TrustedBlockGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	r.ParseForm()
	chainStr := vars["chain"]
	indexStr := r.Form.Get("index")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var id uint64
	if indexStr != "" {
		id, err = strconv.ParseUint(indexStr, 10, 64)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error index"))
			return
		}
	} else {
		id = core.GetLastBlockIndex(chain) - 30
	}
	key := core.GetTheBlockKey(chain, id)
	if len(key) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("not blocks"))
		return
	}
	w.WriteHeader(http.StatusOK)
	w.Write(key)
}

// MiningBlockGet get block for mining
func MiningBlockGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	r.ParseForm()
	chainStr := vars["chain"]
	// miner := r.Form.Get("miner")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}

	block := handler.GetBlockForMining(chain)
	if block == nil {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("not block"))
		return
	}
	data, _ := json.Marshal(block)
	w.WriteHeader(http.StatusOK)
	w.Write(data)
}

// Admin admin
type Admin struct {
	Cost     uint64 `json:"cost,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionAdminPost register admin candidate
func TransactionAdminPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := Admin{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.RegisterAdmin(info.Cost)
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.TransKey = hex.EncodeToString(key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// AdminsGet get admin list
func AdminsGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	adminList := core.GetAdminList(chain)
	var out []string
	for _, it := range adminList {
		if it.Empty() {
			continue
		}
		val := hex.EncodeToString(it[:])
		out = append(out, val)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// AdminInfo admin info
type AdminInfo struct {
	Address string `json:"address"`
	Deposit uint64 `json:"deposit"`
	Votes   uint64 `json:"votes"`
}

// AdminInfoGet get admin info
func AdminInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	key := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	addr := core.Address{}
	addr.Decode(key)

	info := core.GetAdminInfo(chain, addr)
	var out AdminInfo
	out.Address = key
	out.Deposit = info.Deposit
	out.Votes = info.Votes

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// VoteInfo vote info
type VoteInfo struct {
	Address  string `json:"address,omitempty"`
	Admin    string `json:"admin,omitempty"`
	Votes    uint64 `json:"votes,omitempty"`
	StartDay uint64 `json:"start_day,omitempty"`
}

// VoteInfoGet get vote info
func VoteInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	key := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	if key == "" {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("need key query"))
		return
	}
	addr := core.Address{}
	addr.Decode(key)

	info := core.GetVoteInfo(chain, addr)
	var out VoteInfo
	out.Address = key
	if !info.Admin.Empty() {
		out.Admin = hex.EncodeToString(info.Admin[:])
	}
	out.StartDay = info.StartDay
	out.Votes = info.Cost / 1000000000
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// VoteReward vote reward
type VoteReward struct {
	Reward uint64 `json:"reward,omitempty"`
	Day    uint64 `json:"day,omitempty"`
}

// VoteRewardGet get vote info
func VoteRewardGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	var day uint64
	day = uint64(time.Now().Unix() / 3600 / 24)
	dayStr := r.Form.Get("day")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	if dayStr != "" {
		day, err = strconv.ParseUint(dayStr, 10, 64)
	}

	var out VoteReward
	out.Day = day
	info := core.GetVoteReward(chain, day)
	out.Reward = info.Reward
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// ChainsGet get chains list
func ChainsGet(w http.ResponseWriter, r *http.Request) {
	out := make([]uint64, 0, 100)
	visit := make([]uint64, 1, 100)
	visit[0] = 1
	for len(visit) > 0 {
		chain := visit[0]
		visit = visit[1:]
		id := core.GetLastBlockIndex(chain)
		if id == 0 {
			continue
		}
		visit = append(visit, chain*2, chain*2+1)
		out = append(out, chain)
	}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}
